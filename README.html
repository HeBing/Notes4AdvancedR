<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Notes on <a href="http://adv-r.had.co.nz/">Advanced R</a></title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>





</head>

<body>
<h2>Notes on <a href="http://adv-r.had.co.nz/">Advanced R</a></h2>

<p>by Bing He</p>

<h3><a href="http://adv-r.had.co.nz/Introduction.html">Introudction</a></h3>

<ol>
<li>Two meta-techniques to learn R:

<ul>
<li>read source code</li>
<li>develop a scientific mindset: try &amp; error</li>
</ul></li>
</ol>

<h3><a href="http://adv-r.had.co.nz/Data-structures.html">Data sturcture</a></h3>

<ol>
<li>When you attempt to combined different types of atomic vectors, they will be <em><em>coerced</em></em> to the most flexible type. Types from least to most flexible are: logic, integer, double, and character.</li>
<li>All objects can have arbitrary additional attributes. Attributes can be thought as named list.</li>
<li><code>structure()</code> function returns a new object with modified attributes, e.g., <code>structure(1:10, my_attribute = &quot;This is a vector&quot;)</code>.</li>
<li>Remove names of vectors by <code>unname(x)</code> or <code>names(x) = NULL</code>.</li>
<li>In data loading functions in R, you can use <code>stringsAsFactor=FALSE</code> to preventing automatic conversion of character to factor.</li>
<li>use <code>dimnames()</code> to change names of array</li>
<li><code>abind()</code> is the generalized version for <code>cbind()</code>/<code>rbind()</code> for array. <code>aperm()</code> is the generalization of <code>t()</code> for array.</li>
<li>Under the hood, data frame is a list of equal-length vectors. </li>
<li><strong>You can add a column that is a list/array/matrix to a dataframe, using <code>I()</code>, e.g. <code>dfl &lt;- data.frame(x = 1:3, y = I(list(1:2,1:3,1:4)))</code></strong>.</li>
</ol>

<h3><a href="http://adv-r.had.co.nz/Subsetting.html">Subsetting</a></h3>

<ol>
<li>R&#39;s subsetting operators are powerful and fast, and mastering them allows you to express complex operations in a succinct fashion few other languages can match.</li>
<li><strong>Matrices and arrays are implemented as vectors with special attributes (like <code>dim</code>), you can also subset them with a single vector. In that case they will behave like a vector. Arrarys in R are stored in column-major order.</strong></li>
<li>Data frames possess the characteristics of <strong>both lists and matrices</strong>: if you subset with <strong>a single vector</strong>, they behave like lists; if you subset with two vectors, they behave like matrices. For example, <code>df[c(&quot;col1&quot;,&quot;col2&quot;)]</code> subsets a data frame as it is a list; and <code>df[,c(&quot;col1&quot;,&quot;col2&quot;)]</code> subsets a data frame as it is a matrix. <strong>There is an important difference if you select a single column: matrix subsetting simplifies by default, list subsetting does not</strong>. In matrix subsetting, you can use the argument <code>drop=F</code> to prevent automatic simplification, i.e., <code>df[,&quot;col1&quot;,drop=F]</code>.</li>
<li>S3 objects are made of atomic vectors, arrays and lists, so you can always use above subsetting techiques to extract a field. For S4 objects, two additional subsetting operators are used <code>@</code> (like <code>$</code>) and <code>slot()</code> (equivalent to <code>[[</code>).</li>
<li><code>upper.tri(matrix)</code> gives TRUE in upper triangle of matrix.</li>
</ol>

<h4>Simplifying vs preserving subsetting</h4>

<ol>
<li>Simplifying subsets returns the simplest possible data structure, which is very useful for interactively; preserving subsets returns the output in the same format as the input, which is very useful for programming. </li>
<li>omitting <code>drop=FALSE</code> in matrix or data frame subsetting will cause unexpected error when someone pass in a single-column data.</li>
<li>There is a very useful table for simplifying v.s. preserving.

<ul>
<li>vector and list: simplifying <code>[[&#39;; perserving</code>[</li>
<li><strong>factor</strong>: simplifying <code>drop=T</code>, which can <strong>drop any unused levels</strong></li>
<li>array: simplifying <code>drop=FALSE</code></li>
<li>data frame: simplifying <code>x[,1]</code> or <code>x[[1]]</code>; preserving <code>drop=F</code> or <code>x[1]</code>(i.e., treat data frame as a list.)</li>
</ul></li>
<li><code>x$y</code> translates to <code>x[[&quot;y&quot;,exact=FALSE]]</code>. 

<ul>
<li><strong>When you store a column name in a var <code>var &lt;- &quot;ryl&quot;</code>, <code>mtcars$var</code> won&#39;t work. Instead, use <code>mtcars[[var]]</code></strong></li>
<li><code>$</code> does partial matching, that&#39;s why there is a <code>exact=FALSE</code> when we tranlate <code>$</code> into <code>[[</code>.</li>
</ul></li>
<li>Indexing with a blank can be useful in conjunction with assignment because it will preserve the original object class and structure. <code>mtcars[] &lt;- lapply(mtcars, as.integer)</code> will return a data frame, while <code>mtcars &lt;- lapply(mtcars, as.integer)</code> will return a list.</li>
<li>You can use <code>x &lt;- list(a=1,b=2); x[[&quot;b&quot;]] &lt;- NULL</code> to remove components from a list. You can do this with data.frame to remove columns.</li>
<li><strong>A very nice example for Lookup table</strong>: <code>sex &lt;- c(&quot;m&quot;,&quot;f&quot;,&quot;m&quot;,&quot;m&quot;,&quot;m&quot;,&quot;f&quot;); lookup &lt;- c(m = &quot;Male&quot;, f=&quot;Female&quot;)</code>.  Then do <code>lookup[x]</code>.</li>
<li><strong>A very nice example for matching and merging</strong>: <code>grade &lt;- c(1,2,2,3,1); info &lt;- data.frame(grade = 3:1, desc=c(&quot;Excellent&quot;, &quot;Good&quot;, &quot;Poor&quot;)</code>. There are two ways of matching: <code>id &lt;- match(grades, infor$grade); info[id,]</code>. <strong>here <code>match()</code> returns the positions of first argument&#39;s matches elements in the second argument</strong>. Or use <code>rownames(info) &lt;- info$grade; info[as.character(grades),]</code></li>
<li>use <code>df[setdiff(names(df),&quot;z&quot;)]</code> to keep the columns except for <code>z</code>.</li>
<li><code>subset()</code> is a shorthand function for subsetting data frames and saves some typing. For example, <code>subset(mtcars, cyl==4)</code>.</li>
<li>Set operations in R: <code>intersect(x,y); union(x,y); setdiff(x,y)</code> and <code>setdiff(union(x,y),intersect(x,y))</code> for XOR.</li>
</ol>

<h3><a href="http://adv-r.had.co.nz/Vocabulary.html">Vocabulary</a></h3>

<h4>Basics</h4>

<ol>
<li><code>&lt;&lt;-</code>: if var name is not found in local environment, search parent environment until global environment.</li>
<li><code>match(x,table)</code> returns the positions of (first) matches of <code>x</code>&#39;s elements in <code>table</code></li>
<li><code>subset(x,subset,select)</code> subset matrices/data frames that meet conditions. <code>x</code> the matrices/data frame to be subsetted. <code>subset</code> logical expression to select elements (1-dim) or rows (higher dim); <code>select</code> logical expression to select columns.

<ul>
<li>For example, <code>data(CO2); subset(CO2,Plant == &quot;Qn1&quot;, conc)</code>. Note <code>Plant</code> and <code>conc</code> are column names in data frame <code>CO2</code>.</li>
</ul></li>
<li><code>with(data,expr)</code>: a generic function for evaluating an <code>expr</code> with the environment constructed from <code>data</code>. Here <code>data</code> can be an environment, a list, a data frame, or an integer as in <code>sys.call</code>.</li>
<li><code>assign(x,value,pos,envir,inherits)</code>: assign <code>value</code> to <code>x</code>. <code>pos</code>: where to do the assignment, defaulting to current environment.</li>
<li><code>get(x,pos,envir,mode)</code> and <code>mget(x,pos,envir,mode)</code>: get value of one variable (<code>get</code>) or 0 or more varibales (<code>mget</code>) <code>x</code> in environment specified by <code>pos</code>/<code>envir</code>. If <code>mode</code> is specified (e.g., double, integer, or function), only values for variables with specified mode will be returned.</li>
<li><code>all.equal(x,y)</code> compares R objects <code>x</code> and <code>y</code> for <code>near equality</code>. Note the difference between the following 3 examples, <code>d45 &lt;- pi*(1/4 + 1:10)</code>:

<ul>
<li><code>all.equal(tan(d45),rep(1,10))</code> gives <code>TRUE</code>.</li>
<li><code>all.equal(tan(d45),rep(1,10),tolerance=0)</code> gives <code>&quot;Mean relative difference: 1.29526e-15&quot;</code>. Comparing the above two examples, we know that <code>all.equal()</code> allows for small difference in numeric results.</li>
<li><code>all(tan(d45)==rep(1,10))</code> gives <code>FALSE</code>, because <code>all</code> is exact match in R.</li>
</ul></li>
<li><code>identical()</code> can be used to test whether two R objects are exactly the same. It is a safe and good way compared than <code>==</code>, <code>&amp;&amp;</code></li>
<li><code>is.finite()</code> test for <code>Inf</code> in data.</li>
<li><code>%%</code> modulas calculator. <code>%/%</code> integer division <code>5%/%2</code> is <code>2</code>.</li>
<li><code>sign,acos,asin,atan,atan2</code>; for positive arguments <code>atan2(y, x) == atan(y/x)</code>. </li>
<li><code>ceiling,floor,round,trunc,signif</code>. <code>trunc</code> truncates the value toward 0.</li>
<li><code>prod(...,na.rm=FALSE)</code> returns the product of all values present in its arguments.</li>
<li><code>cummax,cummin,cumprod,cumsum</code>, and <code>diff(x,lag=1,differences=1)</code> lagged and iterated differences.</li>
<li><code>pmax</code> and <code>pmin</code> are the element-wise max/min of its arguments.</li>
<li><code>range()</code></li>
<li><code>rle()</code>: run length encoding and <code>inverse.rle()</code> reconstructs vectors from run length encoding.</li>
<li><code>missing()</code> can be used to test whether a value was specified as an argument to a function. </li>
<li><code>on.exit(expr = NULL, add = FALSE)</code>: execute code on exit of function. Typical use for graphic parameter settings: <code>test &lt;- function(x) {oldpar &lt;- par(frow=c(2,2)); on.exit(par(oldpar))}</code></li>
<li><code>invisible()</code> return an invisible copy (not print if not assigned) from a function.</li>
<li><code>isTRUE(expr)</code> is equivalent to <code>identical(TRUE, expr)</code></li>
<li><code>xor(x,y)</code></li>
<li><code>setequal(x,y)</code></li>
<li><code>sweep(array, margin, stats, fun)</code> sweep a summary stats as fun defined to the margin of the array.</li>
<li><code>data.matrix</code> converts all columns in a data frame into numeric mode and save as a matrix.</li>
<li><code>rep,rep.int,rep_len</code>: <code>rep.int(x,times)</code> replicate vector <code>x</code> <code>times</code> times. <code>rep_len(x,length.out)</code> replicate vector <code>x</code> until its length reaches <code>length.out</code>.</li>
<li><code>seq,seq_along,seq_len,seq.int</code>: <code>seq_along(x)</code> and <code>seq_len(length.out)</code> generates integers starting from 1 to the <code>length(x)</code> or <code>length.out</code>.</li>
<li><code>rev(x)</code> returns a reversed version of its argument</li>
<li><code>sample(x,size,replace,prob)</code>: <code>x</code> vector to be sampled from; <code>size</code> numbers of elements to be sampled.</li>
<li><code>choose(n,k)</code> returns binomial coefficients.</li>
<li><code>unlist</code> returns a vector contains all atomic components in the list</li>
<li><code>split(x, f, drop = FALSE, ...)</code>: split <code>x</code> according to factor <code>f</code>, <code>drop=T</code> to drop levels in <code>f</code> that does not occur.</li>
<li><code>expand.grid</code> create a data frame that have all the combinations of provided vector/factor. For example, <code>expand.grid(height = seq(60, 80, 5), weight = seq(100, 300, 50), sex = c(&quot;Male&quot;,&quot;Female&quot;))</code>.</li>
<li><code>next/break</code></li>
<li><code>switch(EXPR, alternatives)</code> if <code>EXPR</code> is character/string, alternatives are named and matched by names; if <code>EXPR</code> is integer, alternatives can be without names and are matched by order of occurence. <code>switch</code> can be used within function.</li>
<li><code>ISOdate, ISOdatetime, strptime(&quot;Tue, 23 Mar 2010 14:36:38 -0400&quot;,  &quot;%a, %d %b %Y %H:%M:%S %z&quot;)</code> convert string to date or backwards. <code>difftime</code> creates time intervals,<code>julian,months,quarters,weekdays</code> extracts julian time, month, quarter, and weekday of a date. <strong>Julian time is number of days since origin</strong>.</li>
</ol>

<h4>String</h4>

<ol>
<li><code>agrep(pattern,x)</code> approximate string match which finds matches of <code>x</code>&#39;s element to <code>pattern</code> using edit distance.</li>
<li>String match:

<ul>
<li><code>grep(x,pattern,value=FALSE)</code> returns the incides of the elements of <code>x</code> to <code>pattern</code>; </li>
<li><code>grep(x,pattern,value=TRUE)</code> returns the character vectors containing the matched elements.</li>
<li><code>grepl</code> returns a logical vector</li>
</ul></li>
<li><code>sub/gsub(x,pattern,replacement)</code> substitute matches in <code>x</code> to <code>pattern</code> with <code>replacement</code>. <code>gsub()</code> is global substitution (all matches); <code>sub</code> is first match. 

<ul>
<li>use <code>perl=TRUE</code> to enable perl-style regular expression.</li>
</ul></li>
<li><code>strsplit(x,split,perl)</code> split each element in <code>x</code> by <code>split</code>. The return value is <code>list</code>, you can use <code>unlist()</code> to transform the returned value to a vector.</li>
<li><code>chartr(old,new,x)</code> translate each character in <code>x</code> from <code>old</code> to <code>new</code>. For example, <code>chartr(&quot;iXs&quot;, &quot;why&quot;, x)</code>.</li>
<li><code>nchar</code> num of characters</li>
<li><code>library(stringr)</code></li>
</ol>

<h4>Statistics</h4>

<ol>
<li>For <code>factor</code>, <code>levels,nlevels,reorder,relevel</code>; <code>cut(x,breaks)</code> cuts <code>x</code> according to <code>breaks</code> and return a factor.</li>
<li><code>findInterval(x,vec)</code>: <code>vec</code> is vector of increasing numbers, representing intervals; <code>i &lt;- findInterval(x,vec)</code>: <code>v[i[j]] &lt;= x[j] &lt; v[i[j+1]]</code></li>
<li><code>aperm(a,perm)</code> transpose an array by permuting its dimensions.</li>
<li><code>duplicated(x)</code> returns a logical vector with the same length of <code>x</code>: <code>TRUE</code>indicates this element is the same as some element with smaller subscript. <code>x[!duplicated(x)]</code> extracts the unique values.</li>
<li><code>ftable()</code> flat contigency table</li>
<li><code>merge(x,y,by=)</code> merge <code>x</code> and <code>y</code> by common columns or rownames</li>
<li><code>fitted, predict, resid, rstandard, influence.measures, rstudent(),hat, deviance</code></li>
<li><code>logLik(object, REML=FALSE)</code> extract log likelihood from a fitted model, for example, you can extract log-likelihood from <code>glm()</code></li>
<li><code>I()</code> treat as &ldquo;as is&rdquo;</li>
<li><code>anova,coef,confint,vcov</code>; <code>contrasts</code> sets the constrasts associated with a factor.</li>
<li><code>crossprod, tcrossprod</code>: <code>t(x) %*% y (crossprod)</code> or <code>x %*% t(y) (tcrossprod)</code></li>
<li><code>%o%</code> outer product for matrices/arrays. </li>
<li><code>outer(month.abb, 1999:2003, FUN = &quot;paste&quot;)</code>.</li>
<li><code>rcond</code> returns conditional number of a matrix</li>
</ol>

<h4>Help</h4>

<ol>
<li><code>apropos(what)</code> find objects by partial match of names. For example, <code>apropos(&quot;../test&quot;)</code> returns test functions in R.</li>
<li><code>exists</code> look for an R object with given name</li>
<li><code>require</code> is the same as <code>library</code>, but <code>require</code> is designed for use within function. For non-existing packages, <code>require</code> throws a warning, while <code>library</code> throws an error.</li>
<li><code>RSiteSearch,citation,demo,example</code> and <code>vignette(&quot;grid&quot;)</code></li>
<li><code>help.search(&quot;linear models&quot;)</code></li>
</ol>

<h4>Debugging and error handling</h4>

<ol>
<li><code>options(error = recover)</code> when error occurs, automatically list the current active function calls. By selecting a function call, this allows user to browse directly on the function call; can also be called with <code>recover()</code>. After choosing an active function call, then it behaves just like <code>browser()</code>.</li>
<li><code>geterrmessage()</code> gives the last error.</li>
<li><code>warning(&quot;test it&quot;)</code> generates a warning that corresponds to its argument</li>
<li><code>stop(&quot;error here!\n&quot;)</code> stop current computing</li>
<li><code>message()</code> generates a message according to its argument</li>
<li>__<code>tryCatch()</code> evaluates the expression and exception handlers__. <a href="http://mazamascience.com/WorkingWithData/?p=912">Here</a> is a nice post about error-handlering in R, where the following codes are extracted:
<code>R
result = tryCatch({
    expr
}, warning = function(w) {
    warning-handler-code
}, error = function(e) {
 error-handler-code
}, finally = {
    cleanup-code
}
</code></li>
<li><p><code>try(expr)</code> evaluates an expression and allow user&#39;s code to handle exception. Returned value is the value of the expr if no error, but an invisible object containing the error. Can be used in <code>if</code> to allow user to handler different exception.</p></li>
<li><p><code>dput</code> write an R object (e.g., like a functioin) to ASCII file.</p></li>
<li><p><code>format</code> an R object for pretty printing. Options <code>trim = FALSE, digits = NULL, nsmall = 0L, justify = c(&quot;left&quot;, &quot;right&quot;, &quot;centre&quot;, &quot;none&quot;)</code>: trim spaces, digits, number of decimals, alignment (justify).</p></li>
<li><p><code>sink</code> <code>capture.output</code> evaluate expression and write the output to a file</p></li>
<li><p><code>count.fields</code> count the number of fields in each row of the file with <code>sep</code></p></li>
<li><p><code>read.fwf()</code> read fixed width field data</p></li>
<li><p><code>readLines(con,n)</code> read n lines from the connection con</p></li>
<li><p><code>readRDS(file=&quot;&quot;)</code> and <code>saveRDS(object, file)</code> read and write a single R object. Useful compared to <code>load</code> as the read in data can be renamed <code>data2 &lt;- readRDS(&quot;data.RData&quot;</code></p></li>
<li><p><code>list.files() list.dirs()</code></p></li>
<li><p>Given a full path as input, <code>basename</code> removes the path up to the final file; <code>dirname</code> returns the path (excluding the final file).</p></li>
<li><p><code>file_ext</code> returns the file extension in the directory</p></li>
<li><p><code>file.path()</code> concatenate the string arguments separating by <code>/</code></p></li>
<li><p><code>path.expand</code> expandes a relative path to full path. <code>path.expand(&quot;~/foo&quot;)</code> gives <code>[1] &quot;C:\\Users\\Bing He\\Documents/foo&quot;</code></p></li>
<li><p><code>normalizePaht(x,winslash=&quot;//&quot;)</code> express file path in a platform-friendly way. For example, change the backward slash to forward slash to be compatible with windows platform.</p></li>
<li><p><code>file.choose()</code> will promot a file selection GUI window</p></li>
<li><p><code>file.copy, file.create, file.remove, file.rename, dir.create</code></p></li>
<li><p><code>file.exists, file.info</code></p></li>
<li><p><code>tempdir, tempfile</code> returns a path and name appropriate for temporary directory and file.</p></li>
<li><p><code>download.file(url,destfile)</code> download a file from Internet to the destination file <code>destfile</code></p></li>
</ol>

<h3><a href="http://adv-r.had.co.nz/Functions.html">Functions</a></h3>

<h4>Function Basics</h4>

<ol>
<li>Function is also an R object just like any other R object. There are three components of a function: <code>body()</code>, <code>formals()</code> (argument list), and <code>environment()</code>. Function can have user-defined attributes. For example, you can set the <code>class()</code> and add a custom <code>print()</code> method.</li>
<li>Primitive functions call C code directly with <code>.Primitive()</code> and contain no R code. Primitive functions are only found in the <code>base</code> R package.</li>
<li>Use <code>ls(&quot;package:base&quot;, all = TRUE)</code> to list all objects in the base package.</li>
</ol>

<h4>Lexical scoping</h4>

<ol>
<li>Four principles of lexical scoping in R

<ul>
<li>Name masking</li>
<li>Functions v.s. variables</li>
<li>a fresh start</li>
<li>Dynamic lookup</li>
</ul></li>
<li>Lexical scoping looks up symbol values based on how functions were nested when they were defined, not how they are nested when they are called. </li>
<li>First look inside the current function, then where that function was defined, and so on, all the way up to the global environment, and then on to other loaded packages. </li>
<li>closures: functions created by other functions. It is easy to create a function using a user-defined function, just return the function name. This function will preserve the environment in which it was defined.</li>
<li>Looking up functions are the same as looking up for variable values. When R looks up a name where it is obvious you want a function, R will ignore non-function objects.</li>
<li>Every time a function is called, a new environment is created to host execution. Each invocation of one function is completely independent. </li>
<li>Lexical scoping determines where to look up variable values. When the function is run, R looks for values, not when it&#39;s created.</li>
<li><strong>You want to make a function self-contained, so that its output only depends on its arguments</strong>. You can use <code>findGlobals()</code> function from package <code>codetools</code>, which lists all the external dependencies of a function.</li>
</ol>

<h4>Every operation is a function call</h4>

<ol>
<li>&ldquo;everything that exists in an object; everything that happens is a function call.&rdquo; John Chambers</li>
<li>backtick allows you refer to functions or variables that have otherwise reserved or illegal names. For example, <code>x[3]</code> is equivalent to <code>[`(x,3)</code></li>
<li>It is very useful to combined <code>sapply()/lapply()</code> with &#39;+&#39; and &#39;[&#39;. For example,<code>x &lt;- list(1:10,4:9,10:15); lappy(x,&quot;[&quot;,2)</code>; this is to get the 2nd element of each component of the list.</li>
</ol>

<h4>Calling functions</h4>

<ol>
<li>When calling a funciton, we can specify the arguments by name, by position, and and by partial names. The actual values of arguments are matched to formal arguments, first by exact matching of name, second by partial match of names, and finally by position.</li>
<li>When specifying the arguments, named arguments should be after unamed arugments (matched by position).</li>
<li><strong>call a function with an argument list</strong>: <code>do.call(mean,list(1:10,na.rm=TRUE))</code></li>
<li>Note you can determine if an argument was supplied or not with the <code>missing()</code> inside a function.</li>
<li>When specifying default values but it takes a few lines of code to compute, you can set the default value to <code>NULL</code> and then inside the funciton, us <code>is.null()</code> to test whether the value is given, then add your lines of code for calcualting the default value.</li>
</ol>

<h4>Lazy evaluation</h4>

<ol>
<li>by default, R function arguments are lazy. The arguments are only evaluated if they are actually used. Use <code>force</code> to force evluation.</li>
<li>Default values are evaluated inside function. But arguments given function are evaluated in the environment where the function is defined.</li>
<li>Taking advantage of lazy evaluation, we can use <code>!is.null(a) || stop(&quot;a is null\n&quot;)</code></li>
</ol>

<h4>Special calls</h4>

<ol>
<li>infix functions: most functions in R are &ldquo;prefix&rdquo; operators, the name of the function comes before the arguments. You can create infix functions where the function name comes in between its arguments, like <code>+</code> or <code>-</code>.</li>
<li><strong>User-defined infix functions should start and end with <code>%</code></strong>. Their names can contain any special characters (special characters should be escaped). </li>
<li>Replacement functions act like they modify their arguments in place (actually they still make a local temporary copy), and have the special name &ldquo;xxx&lt;-&rdquo;. <code>&quot;second&lt;-&quot; &lt;- function(x,value) { x[2] &lt;- value; x}</code>. Use <code>second(x) &lt;- 5L</code>.</li>
<li>Most R objects have copy-on-modify semantics. So modifying a function argument does not change the original value. <strong>There are two important excepting to copy-on-modify semantics: reference classes and environment. These can be modified in place, so extra care is needed when working with them</strong>.</li>
<li>pure function: functions that always map the smae input ot hte same output and have no other impact on the workspace.</li>
<li>Most base R function are pure functions. Here are some exceptions:

<ul>
<li><code>library</code> loads a package and modifies the search path</li>
<li><code>setwd, Sys.setenv, Sys.setlocale</code> change the working dir, environment variables and the locale respectively.</li>
<li>others</li>
</ul></li>
<li>Invisible return value: <code>f2 &lt;- function() invisible(1); f2(); f2()==1;</code> and <code>(f2())</code> actually prints 1.</li>
<li><code>on.exit()</code> the expression inside is called and evluated when the function terminates. Be cautious if you are using multiple <code>on.exit()</code> calls, need to set <code>add = TRUE</code>. For example, <code>{old &lt;- setwd(dir); on.exit(setwd(old))}</code></li>
</ol>

<h3><a href="http://adv-r.had.co.nz/OO-essentials.html">OO field guide</a></h3>

<ol>
<li>base types

<ul>
<li>base types are internal C struct that describes how that object is stored in memory.</li>
<li>common base types include atomic vectors and lists, functions, environments, and other exotic objects like names, calls, and promises.</li>
<li>determine an object&#39;s base type using <code>typeof()</code></li>
<li>method dispatch for base types are written in C (<code>SWITCH(TYPE)</code>)</li>
</ul></li>
<li>There are 3 OO systems in R: S3, S4, and RC.</li>
<li>S3

<ul>
<li>S3: generic-function OO. A generic function decides which method to call based on the classes of the input arguments. It is the most commonly used system.</li>
<li>Use <code>is.object(x) $ !isS4(x)</code> to determine whether an object is S3 or not</li>
<li>Check source code for a call to <code>UseMethod()</code> to determine whether a function is a S3 generic function.</li>
<li>We can use <code>methods(generic.function,class)</code> to find out methods belong to a generic function using the 1st args, and list all generic functions that have a method for a given class using the 2nd args.</li>
<li>In S3, defining classes and creating objects are accomplished in one simple step, i.e., <code>foo &lt;- structure(list(),class=&quot;foo&quot;)</code> or <code>foo &lt;- list(); class(foo) &lt;- &quot;foo&quot;</code>.</li>
<li>Creating S3 generic function by <code>f &lt;- function(x) UseMethod(&quot;f&quot;); f.a &lt;- function(x) &quot;Class a&quot;; a&lt;- structure(list(),class = &quot;a&quot;); f(a)</code></li>
</ul></li>
<li>S4

<ul>
<li>S4 is more formal than S3. S4 requires formal class definitions. It supports multiple inheritance and multiple dispatches. All S4 related code i stored in <code>library(methods)</code>. Bioconductors contain rich body of code in S4.</li>
<li>Use <code>isS4()</code> to determine whether an object is an S4 object or not.</li>
<li>Use <code>is(x)</code> to list all classes that an object inherits from (for both S3 and S4 objects)</li>
<li>Find the documentation for a class with <code>class?className</code></li>
<li>Use <code>setClass(name, slots, contains)</code> to define the representation of a class and use <code>new()</code> to create one object of the calss. For example, <code>setClass(&quot;Person&quot;,slots = list(name = &quot;character&quot;,age=&quot;numeric&quot;)); alice &lt;- new(&quot;Person&quot;,name=&quot;Alice&quot;,age=40)</code>.</li>
<li>access a specific slot of an S4 object by <code>alice@age</code> or <code>slot(alice,&quot;age&quot;)</code>.</li>
<li>Use <code>setGeneric(&quot;union&quot;)</code> to create a new generic in S4 or converts an existing function into a generic. Then use <code>setMethod()</code> with name of the generic and the method-associated classes, and the function (i.e.method).</li>
</ul></li>
<li>RC (Reference classes)

<ul>
<li>RC implements message-passing OO. RC objects are mutable (or passed by reference insteat of by value); RC methods belong to objects</li>
<li>Use <code>setRefClass()</code> to define a class: <code>Account &lt;- setRefClass(&quot;Account&quot;,fields=list(balance=&quot;numeric&quot;), methods=list(withdraw=function(x){balance &lt;&lt;- balance -x}))</code></li>
<li>Call method use <code>myAccount$deposit(100)</code></li>
<li>use <code>is(x,&quot;refClass&quot;)</code> to check whether an object is RC or not.</li>
</ul></li>
</ol>

</body>

</html>

